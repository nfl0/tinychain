le synchronization le engine
----

- The synchronization engine will be responsible for fetching and updating blocks from other nodes, validating them, and maintaining the state of the tinycoin blockchain.

p2p communication with other nodes (`127.0.0.1:5001` and `127.0.0.1:5002` for demonstration purposes)



tinysync:
    - tinychain supports 1 to 2 nodes.
    - the peer's ip address is hardcoded in `parameters` like so: `PEER_ADDR = '192.168.0.111:5001'`.
    - for the sake of protocol simplicity, both nodes are considered honest all the time.
    - when the two nodes connect, they check each other's chain tip and the syncing process starts.

    - the SynchronizationEngine class updates the transaction pool every second.
    - Transaction synchronization: When a node receives a valid transaction, it should broadcast it to other nodes in the network.
    - Block synchronization: when a node successfully forges a new block, it should broadcast the new block to other nodes for validation and inclusion in their chains.
    - Modify the validation engine to validate incoming blocks in addition to transactions. the block validation includes checking the validity of the block's structure, transactions, and its position in the chain (e.g., checking the previous block hash).
    - fork handling logic tbd. for now, nodes take turn in forging blocks.
    - use websocket from aiohttp, for simple transactions and blocks propagation across the network 

    - Block Validation: When a node forges a new block, it broadcasts it to the network. Other nodes verify the validity of the block, including checking the forger's stake and the correctness of transactions. If the block is valid, it is added to the chain.

future considerations:
    - add an api endpoint for fetching blocks in bulk. for example, this might be useful for the case where a new node joins the network for the first time and has to sync the full blockchain.


"longest chain rule" seem like a good simple fork resolution logic. i think fork resolution logic cant operate without some sort of consensus mechansim, im thinking to implement the simplest consensus mechanism on tinychain called "non-interactive proof of luck". explanation: all the participating nodes compare their public keys to the block hash of the newly forged block and do some computation with the combo that tells each node if its supposed to produce the next block. note: tinychain is expected to have 1 to 3 participating nodes, and security doesnt really matter that much. what do you think?
in tinychain, all participating block producers get to forge a block and all the blocks are subsequently added to the chain.
when the block producer joins the network, it gets the latest block hash and do some math on it in combination with its public key VALIDATOR_PUBLIC_KEY. for this computation, he sets his BLOCK_TIME which tells him when to produce a block. this mechanism should practically eliminate blocks being produced at the same second (collusion). example: after each block producer did the calculation, blockproducer1 produce a block every 4 seconds, blockproducer2 produce on a 7 seconds interval. note: tinychain is expected to have at most 2 nodes

i need you to implement this: tinychain can support up to 2 nodes (block producers), when the second node (node address hardcoded in `parameters`) connects, it starts taking turns with the first node in forging new blocks. 